<!DOCTYPE HTML>
<html lang="en">

<head>
    <title>UP839743-Coursework</title>
    <script src="../WebGLlib/webgl-debug.js"></script>
    <script type="text/javascript" src="../WebGLlib/glMatrix.js"></script>
    <script src="../WebGLlib/webgl-utils.js"></script>
    <meta charset="utf-8">

    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aVertexNormal;
        attribute vec2 aTextureCoordinates;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        uniform mat3 uNMatrix;

        uniform vec3 uLightPosition;
        uniform vec3 uAmbientLightColor;
        uniform vec3 uDiffuseLightColor;
        uniform vec3 uSpecularLightColor;

        varying vec2 vTextureCoordinates;
        varying vec3 vLightWeighting;

        const float shininess = 64.0;
        
        void main() {
            //Get the vertex position in the camera/eye coordinates and convert the homogenous coordinates back to the usual 3d ones for subsequent calculations
            vec4 vertexPositionEye4 = uMVMatrix * vec4(aVertexPosition, 1.0);
            vec3 vertexPositionEye3 = vertexPositionEye4.xyz / vertexPositionEye4.w;

            //Calc the vector (l) to the point light source, first transform the coordinate of light soruce into the eye coord system
            vec4 lightPositionEye4 = uMVMatrix * vec4(uLightPosition, 1.0);
            vec3 lightPositionEye3 = lightPositionEye4.xyz / lightPositionEye4.w;

            //Calc vector (l)
            vec3 vectorToLightSource = normalize(lightPositionEye3 - vertexPositionEye3);
            
            //An alterenate way to calc (l)
            //vec3 vectortoLightSource = normalize(uLightPosition - vertexPositionEye3);

            //transform the normal (n) to the eye coordinates
            vec3 normalEye = normalize(uNMatrix * aVertexNormal);

            //Calculate the n Dot l for diffuse lighting
            float diffuseLightWeighting = max(dot(normalEye, vectorToLightSource), 0.0);

            //calculate the refelection vector (r) that is needed for the specular light.
            //Function() reflect is the GLSL function fot the calculation of the reflective of (r)
            vec3 reflectionVector = normalize(reflect(-vectorToLightSource, normalEye));

            //calculate the view vector (v) (origin aka (0.0, 0.0, 0.0, 0.0) - vertexPositionEye3)
            vec3 viewVectorEye = -normalize(vertexPositionEye3);

            float rdotv = max(dot(reflectionVector, viewVectorEye), 0.0);

            float specularLightWeighting = pow(rdotv, shininess);

            //Sum up all the refelection components and send to the fragment shader
            vLightWeighting = uAmbientLightColor +
                                uDiffuseLightColor * diffuseLightWeighting +
                                uSpecularLightColor * specularLightWeighting;
            
            //Finally transform the geometry
            gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
            vTextureCoordinates = aTextureCoordinates;
        }
    </script>

    <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;
        varying vec2 vTextureCoordinates;
        varying vec3 vLightWeighting;
        uniform sampler2D uSampler;

        void main() {
            vec4 texelColour = texture2D(uSampler, vTextureCoordinates);
            gl_FragColor = vec4(vLightWeighting.rgb * texelColour.rgb, texelColour.a);
        } 
    </script>

    <script src="graphics.js" type="text/javascript"></script>

</head>

<body onload="startup();" style="background-color: black; align-content: center;">
    <canvas id="myGLCanvas" style="margin:auto; display: block;"></canvas>
    <div id="fps-counter" style="color: white;">
        FPS: <span id="fps">--</span>
    </div>
</body>

</html>